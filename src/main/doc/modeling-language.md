### Introduction to the modeling language
A throughput system model can be built using connected combinations of 3 types of components. These components are:
* the source
* the processor
* the balancer

Events flow through the system, interacting with <i>processors</i> and <i>balancers</i>. A <i>source</i> generates events.

<i>Sources</i> and <i>processors</i> can be described by functions called generators. Sources create events separated in time described by the characteristics of the generator. Similarly, processors delay events as described by the generator. A processing component can be characterised as a unit that is resource constrained. While it is processing an event, all other events must wait their turn at the <i>processor</i>.

The <i>balancer</i> provides a mechanism to switch an event to a downstream component from a list of downstream components. The selection of the downstream component is based on the strategy of the function defined for the balancer. A balancer has no delay component in its interaction with an event.

System connectivity is defined within functions, and not by the components. This allows a certain amount of flexibility as we will see later.
#### General language syntax
Given the above, the language has a consistent form for definition - a component, within which is nested a function or functions that describe the component and connectivity to downstream components. The language is case-sensitive. All values are defined in name-value pairs. The name-value pairs do not have to be given in any particular order. Components must always define a <i>name</i> and a <i>type</i>. Everything else is optional. Functions must always define a <i>type</i>. The type of function will dictate legal and mandatory values. Connectivity is defined by the <i>next</i> name-value pair. Double forward slashes define the start of a comment that is ignored by the model compiler. An example of the form is:
```
// Start of a component definition
component
{
    type: source
    name: source
    function
    {
        type: constant
        period: 0.8
        next: network
    }
    monitor: Yes
}
```
### Functions for generators, processors and throttles
#### Constant
As the functional definition for a source, this will generate events a constant interval apart, as set by the value of <i>period</i>. Otherwise for a processor, this represents a fixed delay of <i>period</i>. The definition is:
```
function
{
    type: constant
    period: 0.8
    next: network
}
```
Everything except <i>next</i> is mandatory.
#### Uniform
This produces a uniformly random distribution of values between <i>minimum</i> and <i>maximum</i>. For a source, events are separated by the generated value of the uniform distribution function. For processors, the delay is the generated value of the uniform distribution function.
```
function
{
    type: uniform
    minimum: 5
    maximum: 6
    next: processor 2
}
```
Everything except <i>next</i> is mandatory.
#### Gaussian
The Gaussian function generates values that are normally distributed between <i>minimum</i> and <i>maximum</i>. For sources, this represents the event separation value, and for processors, this is the delay caused by the component.
```
function
{
    type: gaussian
    minimum: 5
    maximum: 6
    next: processor 1
}
```
Everything except <i>next</i> is mandatory.
#### Skewed
This generates values within a certain range but skewed to the left or right, depending on the <i>bias</i> value. This is useful in depicting real-world systems where the response or delay is normally at the lower end, but may occasionally go higher - a right-skewed generator.

Mathematically, the function is:<p>
![alt text](https://raw.githubusercontent.com/BandedHawk/system-simulator/master/src/main/doc/images/skewed.png "Skewing function")

A negative <i>bias</i> value skews the distribution right and a positive value skews the distribution left. The larger the value, the more skewed it becomes.

The <i>skew</i> should be between 0 and 1. The higher the value, the more clustered the distribution is around the mode.

Additional information on the skewing calculation can be found <a href="https://stackoverflow.com/questions/5853187/skewing-java-random-number-generation-toward-a-certain-number">here</a>.
```
function
{
    type: skewed
    minimum: 5.0
    maximum: 6.0
    skew: 0.8
    bias: -3
    next: database
}
```
Everything except <i>next</i> is mandatory.
#### Special cases
For processor and throttle functions, there are additional features. A processor or throttle can have multiple generators declared. A <i>source</i> name-value pair associated with the generator identifies events that are generated by the named <i>source</i> to apply the delay function. A generator without a declared <i>source</i> will be applied to all unhandled sources. The following is an example.
```
component
{
    type: processor
    name: web server
    function
    {
        type: skewed
        minimum: 1.0
        maximum: 2.0
        skew: 0.6
        bias: -2.0
        source: complicated source
        next: database 1
    }
    function
    {
        type: skewed
        minimum: 0.3
        maximum: 0.5
        skew: 0.8
        bias: -3.0
        next: database 2
    }
}
component
{
    type: throttle
    name: web server management
    function
    {
        type: skewed
        minimum: 1.0
        maximum: 2.0
        skew: 0.6
        bias: -2.0
        source: complicated source
        next: web server
    }
    function
    {
        type: skewed
        minimum: 0.3
        maximum: 0.5
        skew: 0.8
        bias: -3.0
        next: web server
    }
}
```
This modification allows different modeling to be applied based on incoming event origins such as different web requests and also allows different downstream paths based on event origin. At this point in time, the statistics generated aren't as useful for throughput measurements but wait times, and utilization of components will still be true, as will overall processing ratios.
### Distributor functions
The functions described here apply to the Balancer component, and define the way that an event is distributed between downstream components.
#### Round-robin
The distribution strategy is to cycle sequentially through the given list of targets, sending each subsequent event through the next component in the sequence. At the end of the sequence, the allocation will return to the top of the list. There is no theoretical limit to the number of downstream components that can be listed.
```
function
{
    type: round-robin
    next: web server 1
    next: web server 2
}
```
#### Smart
This is an ideal distribution strategy. It diverts an event to the next available downstream target. There is no theoretical limit to the number of downstream components that can be listed.
```
function
{
    type: smart
    next: web server 1
    next: web server 2
}
```
#### Random
This is a uniform random distribution strategy. It diverts an event to random selection of downstream targets. This may be useful in complex situations involving source-based routing. There is no theoretical limit to the number of downstream components that can be listed.
```
function
{
    type: random
    next: web server 1
    next: web server 2
}
```
### Components
#### Source
A <i>source</i> is the system entry point for events, and their arrival rate is modeled by the source function. The <i>source</i> can only have one function. The <i>monitor</i> name-value pair toggles monitoring output at the end of the simulation.

The <i>source</i> component cannot be connected downstream of any other component. Only a generator function can be declared in the <i>source</i>.
```
component
{
    type: source
    name: source
    function
    {
        type: uniform
        minimum: 1.5
        maximum: 2.5
        next: network
    }
    monitor: Yes
}
```
#### Processor
The <i>processor</i> is modeled as a delay element in the system. It is a single unit since when it is processing an event, all other events waiting for the <i>processor</i> must wait until the processing is complete. Only a generator function can be declared in the <i>processor</i>.

Real servers can be approximated by parallel copies of a processor model, exhibiting the delay characteristics of the real system. Typically, 3 to 4 parallel units would be sufficient to represent a real server. The maximum incoming rate before non-linear effects prevail will inform as to how many parallel processors would model the complex server adequately. It is beyond the scope of this text to explain modeling approximations but suffice to say that these are generally good enough to give insight into the operation of the wider system under load.

Processors may also declare queue priority for incoming events generated by a source. This means that if there are events queued for processing, the <i>source</i> declared first with <i>priority</i> will be processed first. If there are no events waiting for the processor to be freed, execution is still on a first come first, served basis.. Multiple declarations of <i>priority</i> may be made for a processor, and the order of declarations defines the priority. The first <i>source</i> declared will have the highest priority and so on. The <i>priority</i> declaration is optional.

Processors can have multiple generators declared but they must specify <i>source</i> targets, and have one default. Specifying the <i>source</i> in a generator indicates the generator delay characyeristics will apply to events that came from that source. This was described [earlier](#special-cases). The simplest form of processor declaration is given here.
```
component
{
    type: processor
    name: network
    {
        type: skewed
        minimum: 0.20
        maximum: 0.30
        skew: 0.8
        bias: -2.0
        next: load balancer
    }
    monitor: Y
}
```
#### Throttle
A throttle limits throughput without adding any processing. Throughput limitation is in the form of a cooldown period specified by the declared function. After an event passes through the component, the component is not available until the cooldown period has passed. It does not add to the processing time to the event. It is purely a wait time. The declaration for the throttle is the same form as for the processor. The simplest form of the throttle is provided below.
```
component
{
    type: throttle
    name: operating system overhead
    {
        type: skewed
        minimum: 0.20
        maximum: 0.30
        skew: 0.8
        bias: -2.0
        next: load balancer
    }
    monitor: Y
}
```
#### Balancer
The <i>balancer</i> is merely a means for distributing an event to one of many downstream components. It has no inherent delay characteristics itself. Only a distributor function can be declared in the <i>source</i>.
```
component
{
    type: balancer
    name: load balancer
    function
    {
        type: smart
        next: web server 1
        next: web server 2
        next: web server 3
    }
}
```
#### Connectivity
Multiple upstream components can be connected to a downstream component.This combined with the other features of the implemented modeler allows a wide range of options to approximate real world systems.